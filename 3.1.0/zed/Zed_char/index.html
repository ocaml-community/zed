<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Zed_char (zed.Zed_char)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">zed</a> &#x00BB; Zed_char</nav><h1>Module <code>Zed_char</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type for glyphs.</p><p>To represent a grapheme in unicode is a bit more complicated than what is expected: a printable UChar. For example, diacritics are added to IPA(international phonetic alphabet) letter to produce a modified pronunciation. Variation selectors are added to a CJK character to specify a specific glyph variant for the character.</p><p>Therefore the logical type definition of <code>Zed_char.t</code> can be seen as</p><pre><code class="ml">type Zed_char.t= {
  core: UChar.t;
  combined: UChar.t list;
}</code></pre></dd></dl><dl><dt class="spec type" id="type-char_prop"><a href="#type-char_prop" class="anchor"></a><code><span class="keyword">type</span> char_prop</code><code> = </code><table class="variant"><tr id="type-char_prop.Printable" class="anchored"><td class="def constructor"><a href="#type-char_prop.Printable" class="anchor"></a><code>| </code><code><span class="constructor">Printable</span> <span class="keyword">of</span> int</code></td></tr><tr id="type-char_prop.Other" class="anchored"><td class="def constructor"><a href="#type-char_prop.Other" class="anchor"></a><code>| </code><code><span class="constructor">Other</span></code></td></tr><tr id="type-char_prop.Null" class="anchored"><td class="def constructor"><a href="#type-char_prop.Null" class="anchor"></a><code>| </code><code><span class="constructor">Null</span></code></td></tr></table></dt></dl><aside><p>The property of a character. It can be either <code>Printable of width</code>, <code>Other</code>(unprintable character) or <code>Null</code>(code 0).</p></aside><dl><dt class="spec value" id="val-to_raw"><a href="#val-to_raw" class="anchor"></a><code><span class="keyword">val</span> to_raw : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>CamomileLibrary.UChar.t list</span></code></dt><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val</span> to_array : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>CamomileLibrary.UChar.t array</span></code></dt><dt class="spec value" id="val-core"><a href="#val-core" class="anchor"></a><code><span class="keyword">val</span> core : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> CamomileLibrary.UChar.t</code></dt><dd><p><code>core char</code> returns the core of the <code>char</code></p></dd></dl><dl><dt class="spec value" id="val-combined"><a href="#val-combined" class="anchor"></a><code><span class="keyword">val</span> combined : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>CamomileLibrary.UChar.t list</span></code></dt><dd><p><code>combined char</code> returns the combining marks of the <code>char</code></p></dd></dl><dl><dt class="spec value" id="val-unsafe_of_utf8"><a href="#val-unsafe_of_utf8" class="anchor"></a><code><span class="keyword">val</span> unsafe_of_utf8 : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unsafe_of_utf8 str</code> returns a <code>zed_char</code> from utf8 encoded <code>str</code> without any validation.</p></dd></dl><dl><dt class="spec value" id="val-of_utf8"><a href="#val-of_utf8" class="anchor"></a><code><span class="keyword">val</span> of_utf8 : <span>?&#8288;indv_combining:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_utf8 str</code> returns a <code>zed_char</code> from utf8 encoded <code>str</code>. This function checks whether <code>str</code> represents a single <code>UChar</code> or a legal grapheme, i.e. a printable core with optional combining marks. It will raise <code>Failure &quot;malformed Zed_char sequence&quot;</code> If the validation is not passed.</p><dl><dt>parameter indv_combining</dt><dd><p>allow to create a <code>Zed_char.t</code> from a single combining mark, default to <code>true</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-to_utf8"><a href="#val-to_utf8" class="anchor"></a><code><span class="keyword">val</span> to_utf8 : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_utf8 chr</code> converts a <code>chr</code> to a string encoded in UTF-8.</p></dd></dl><dl><dt class="spec value" id="val-zero"><a href="#val-zero" class="anchor"></a><code><span class="keyword">val</span> zero : <a href="index.html#type-t">t</a></code></dt><dd><p>The Character 0.</p></dd></dl><dl><dt class="spec value" id="val-prop_uChar"><a href="#val-prop_uChar" class="anchor"></a><code><span class="keyword">val</span> prop_uChar : CamomileLibrary.UChar.t <span>&#45;&gt;</span> <a href="index.html#type-char_prop">char_prop</a></code></dt><dd><p><code>prop_uChar uChar</code> returns the char_prop of <code>uChar</code></p></dd></dl><dl><dt class="spec value" id="val-prop"><a href="#val-prop" class="anchor"></a><code><span class="keyword">val</span> prop : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-char_prop">char_prop</a></code></dt><dd><p><code>prop ch</code> returns the char_prop of <code>ch</code></p></dd></dl><dl><dt class="spec value" id="val-is_printable"><a href="#val-is_printable" class="anchor"></a><code><span class="keyword">val</span> is_printable : CamomileLibrary.UChar.t <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns whether a <code>UChar.t</code> is a printable character or not.</p></dd></dl><dl><dt class="spec value" id="val-is_printable_core"><a href="#val-is_printable_core" class="anchor"></a><code><span class="keyword">val</span> is_printable_core : CamomileLibrary.UChar.t <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns whether a <code>UChar.t</code> is a printable character and its width is not zero.</p></dd></dl><dl><dt class="spec value" id="val-is_combining_mark"><a href="#val-is_combining_mark" class="anchor"></a><code><span class="keyword">val</span> is_combining_mark : CamomileLibrary.UChar.t <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns whether a <code>UChar.t</code> is a combining mark.</p></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">val</span> size : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>size ch</code> returns the size (number of characters) of <code>ch</code>.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Aliase of size</p></dd></dl><dl><dt class="spec value" id="val-width"><a href="#val-width" class="anchor"></a><code><span class="keyword">val</span> width : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>width ch</code> returns the width of <code>ch</code>.</p></dd></dl><dl><dt class="spec value" id="val-out_of_range"><a href="#val-out_of_range" class="anchor"></a><code><span class="keyword">val</span> out_of_range : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></dt><dd><p><code>out_of_range ch idx</code> returns whether <code>idx</code> is out of range of <code>ch</code>.</p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> CamomileLibrary.UChar.t</code></dt><dd><p><code>get ch n</code> returns the <code>n</code>-th character of <code>ch</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_opt"><a href="#val-get_opt" class="anchor"></a><code><span class="keyword">val</span> get_opt : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>CamomileLibrary.UChar.t option</span></code></dt><dd><p><code>get ch n</code> returns an optional value of the <code>n</code>-th character of <code>ch</code>.</p></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> CamomileLibrary.UChar.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>append ch cm</code> append the combining mark <code>cm</code> to ch and returns it. If <code>cm</code> is not a combining mark, then the original <code>ch</code> is returned.</p></dd></dl><dl><dt class="spec value" id="val-compare_core"><a href="#val-compare_core" class="anchor"></a><code><span class="keyword">val</span> compare_core : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare_core ch1 ch2</code> compares the core components of ch1 and ch2</p></dd></dl><dl><dt class="spec value" id="val-compare_raw"><a href="#val-compare_raw" class="anchor"></a><code><span class="keyword">val</span> compare_raw : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare_raw ch1 ch2</code> compares over the internal characters of ch1 and ch2 sequentially</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Alias of compare_raw</p></dd></dl><dl><dt class="spec value" id="val-mix_uChar"><a href="#val-mix_uChar" class="anchor"></a><code><span class="keyword">val</span> mix_uChar : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> CamomileLibrary.UChar.t <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-t">t</a>, <a href="index.html#type-t">t</a>)</span> Result.result</span></code></dt><dd><p><code>mix_uChar chr uChar</code> tries to append <code>uChar</code> to <code>chr</code> and returns <code>Ok result</code>. If <code>uChar</code> is not a combining mark, then an <code>Error (Zed_char.t consists of uChar)</code> is returned.</p></dd></dl><dl><dt class="spec value" id="val-of_uChars"><a href="#val-of_uChars" class="anchor"></a><code><span class="keyword">val</span> of_uChars : <span>?&#8288;trim:bool</span> <span>&#45;&gt;</span> <span>?&#8288;indv_combining:bool</span> <span>&#45;&gt;</span> <span>CamomileLibrary.UChar.t list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> option</span> * <span>CamomileLibrary.UChar.t list</span></code></dt><dd><p><code>of_uChars uChars</code> transforms <code>uChars</code> to a tuple. The first value is an optional <code>Zed_char.t</code> and the second is a list of remaining uChars. The optional <code>Zed_char.t</code> is either a legal grapheme(a core printable char with optinal combining marks) or a wrap for an arbitrary UChar.t. After that, all remaining uChars returned as the second value in the tuple.</p><dl><dt>parameter trim</dt><dd><p>trim leading combining marks before transforming, default to <code>false</code></p></dd></dl><dl><dt>parameter indv_combining</dt><dd><p>create a <code>Zed_char</code> from an individual dissociated combining mark, default to <code>true</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-zChars_of_uChars"><a href="#val-zChars_of_uChars" class="anchor"></a><code><span class="keyword">val</span> zChars_of_uChars : <span>?&#8288;trim:bool</span> <span>&#45;&gt;</span> <span>?&#8288;indv_combining:bool</span> <span>&#45;&gt;</span> <span>CamomileLibrary.UChar.t list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> list</span> * <span>CamomileLibrary.UChar.t list</span></code></dt><dd><p><code>zChars of_uChars uChars</code> transforms <code>uChars</code> to a tuple. The first value is a list of <code>Zed_char.t</code> and the second is a list of remaining uChars.</p><dl><dt>parameter trim</dt><dd><p>trim leading combining marks before transforming, default to <code>false</code></p></dd></dl><dl><dt>parameter indv_combining</dt><dd><p>create a <code>Zed_char</code> from an individual dissociated combining mark, default to <code>true</code></p></dd></dl></dd></dl><dl><dt class="spec value" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span class="keyword">val</span> for_all : <span>(CamomileLibrary.UChar.t <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>for_all p zChar</code> checks if all elements of <code>zChar</code> satisfy the predicate <code>p</code>.</p></dd></dl><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(CamomileLibrary.UChar.t <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iter f char</code> applies <code>f</code> on all characters of <code>char</code>.</p></dd></dl><aside><p>The prefix 'unsafe_' of <code>unsafe_of_char</code> and <code>unsafe_of_uChar</code> means the two functions do not check if <code>char</code> or <code>uChar</code> being transformed is a valid grapheme. There is no 'safe_' version, because the scenario we should deal with a single <code>char</code> or <code>uChar</code> is when the char sequence are individual, incomplete. For example, when we are reading user input. Even if a user wants to input a legal grapheme, say, 'a' with a hat(a combining mark) on top. the user will input 'a' and then '^' individually, the later combining mark is always illegal. What we should do is to invoke <code>unsafe_of_uChar user_input</code> and send the result to the edit engine. Other modules in zed, like Zed_string, Zed_lines, Zed_edit ... are already well designed to deal with such a situation. They will do combining mark joining, grapheme validation for you automatically. Use the two 'unsafe_' functions directly, you're doing things the right way.</p></aside><dl><dt class="spec value" id="val-unsafe_of_char"><a href="#val-unsafe_of_char" class="anchor"></a><code><span class="keyword">val</span> unsafe_of_char : char <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unsafe_of_char ch</code> returns a <code>Zed_char</code> whose core is <code>ch</code>.</p></dd></dl><dl><dt class="spec value" id="val-unsafe_of_uChar"><a href="#val-unsafe_of_uChar" class="anchor"></a><code><span class="keyword">val</span> unsafe_of_uChar : CamomileLibrary.UChar.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>unsafe_of_uChar ch</code> returns a <code>Zed_char</code> whose core is <code>ch</code>.</p></dd></dl><dl><dt class="spec module" id="module-US"><a href="#module-US" class="anchor"></a><code><span class="keyword">module</span> <a href="US/index.html">US</a> : <span class="keyword">functor</span> (<a href="US/index.html#argument-1-US">US</a> : CamomileLibrary.UnicodeString.Type) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Converting between <code>UnicodeString.Type</code> and <code>Zed_char.t</code></p></dd></dl></div></body></html>